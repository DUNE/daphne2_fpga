-- trig_xc.vhd
-- matching filter cross correlation self trigger full module 
--
-- This module connects the high pass first order IIR filter used to subtract the baseline
-- from the AFE data with the matching filter core module, so that the last one receives 
-- the proper data and triggers in the right conditions
-- The baseline output generated by this module is delayed by 4 clock ticks, this is
-- related to the pipeline stages created inside the filter
--
-- Daniel Avila Gomez <daniel.avila.gomez@cern.ch>

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_signed.all;

library unisim;
use unisim.vcomponents.all;

entity trig_xc is
port(
    reset: in std_logic;
    clock: in std_logic;
    din: in std_logic_vector(13 downto 0);
    threshold: in std_logic_vector(41 downto 0); -- matching filter trigger threshold values
    baseline: out std_logic_vector(13 downto 0); -- this baseline is delayed 4 clock ticks
    triggered: out std_logic;
    trigsample: out std_logic_vector(13 downto 0)
);
end trig_xc;

architecture trig_xc_arch of trig_xc is

    signal st_xc_filt_dout: std_logic_vector(13 downto 0);
    signal afe_reg0, afe_reg1, afe_reg2, afe_reg_delayed32, afe_reg_delayed64: std_logic_vector(13 downto 0) := (others => '0');
    signal afe_del_reg0, afe_del_reg1, afe_del_reg2: std_logic_vector(13 downto 0) := (others => '0');
    signal trigsample_reg: std_logic_vector(13 downto 0) := (others => '0');
    signal triggered_core, trig_reg: std_logic;
    signal hold_trigsample: std_logic;
    signal hold_trigsample_counter: std_logic_vector(11 downto 0);

    component st_xc_filt is -- high pass first order iir filter for the algorithm (subtracts the baseline)
    port(
        reset: in std_logic;
        clock: in std_logic;
        din: in std_logic_vector(13 downto 0);
        dout: out std_logic_vector(13 downto 0));
    end component;

    component st_xc is -- cross correlation matching filter component
    port(
        reset: in std_logic;
        clock: in std_logic;
        din: in std_logic_vector(13 downto 0);
        threshold: in std_logic_vector(41 downto 0); 
        triggered: out std_logic);
    end component;

begin

    -- generate the filtered output that does not have a baseline
    
    st_xc_filt_inst: st_xc_filt
    port map(
        reset => reset,
        clock => clock,
        din => din,
        dout => st_xc_filt_dout
    );

    -- use the filtered output to watch over the data and generate self triggers
    
    st_xc_inst: st_xc
    port map(
        reset => reset,
        clock => clock,
        din => st_xc_filt_dout,
        threshold => threshold,
        triggered => triggered_core
    );

    -- since the output of the filter is the signal with no baseline, the baseline can be
    -- obtained by subtracting the filter's output from the AFE data
    -- NOTE: filter's output has 3 pipelining stages therefore the baseline will be delayed 3 clock ticks 
    
    afe_delay: process(clock, reset, din, afe_reg0, afe_reg1)
    begin
        if rising_edge(clock) then
            if (reset='1') then
                afe_reg0 <= (others => '0');
                afe_reg1 <= (others => '0');
                afe_reg2 <= (others => '0');
            else
                afe_reg0 <= din;
                afe_reg1 <= afe_reg0;
                afe_reg2 <= afe_reg1;
            end if;
        end if;
    end process afe_delay;

    -- generate the extra 64 clock ticks delay that mimics the one inside the self trigger core

    gendelay: for i in 13 downto 0 generate

        srlc32e_0_inst : srlc32e
        port map(
            clk => clock,
            ce => '1',
            a => "11111",
            d => afe_reg2(i), -- real time AFE data
            q => open,
            q31 => afe_reg_delayed32(i) -- AFE data 32 clocks ago
        );

        srlc32e_1_inst : srlc32e
        port map(
            clk => clock,
            ce => '1',
            a => "11111",
            d => afe_reg_delayed32(i), -- AFE data 32 clocks ago
            q => afe_reg_delayed64(i), -- AFE data 64 clocks ago
            q31 => open
        );
        
    end generate gendelay;
    
    -- generate the extra clock ticks delay that is generated because of the pipelining in the 
    -- lst calculations of the triggering module
    
    afe_reg_delay: process(clock, reset, afe_reg_delayed64, afe_del_reg0, afe_del_reg1)
    begin
        if rising_edge(clock) then
            if (reset='1') then
                afe_del_reg0 <= (others => '0');
                afe_del_reg1 <= (others => '0');
                afe_del_reg2 <= (others => '0');
            else
                afe_del_reg0 <= afe_reg_delayed64;
                afe_del_reg1 <= afe_del_reg0;
                afe_del_reg2 <= afe_del_reg1;
            end if;
        end if;
    end process afe_reg_delay;

    -- subtract the high pass filter's output to obtain the baseline
    
    baseline_calc: process(clock, reset, afe_reg2, st_xc_filt_dout)
    begin
        if rising_edge(clock) then
            if (reset='1') then
                baseline <= (others => '0');
            else
                baseline <= std_logic_vector(signed(afe_reg2) - signed(st_xc_filt_dout));
            end if;
        end if;
    end process baseline_calc;

    -- determine the sample that asserted the trigger 

    xc_trigsample_proc: process(clock, reset, trig_reg, triggered_core, afe_del_reg2, hold_trigsample, hold_trigsample_counter)
    begin
        if rising_edge(clock) then
            if (reset='1') then
                trig_reg <= '0';
                hold_trigsample <= '0';
                trigsample_reg <= (others => '0');
                hold_trigsample_counter <= (others => '0');
            else
                trig_reg <= triggered_core;
                if ( trig_reg='0' and triggered_core='1' and hold_trigsample='0' ) then
                    -- a trigger just happened, show the sample that caused it                    
                    trigsample_reg <= afe_del_reg2;
                    hold_trigsample <= '1';
                end if;    

                -- hold the trigger sample 
                if (hold_trigsample='1') then
                    -- count at least 10 clock ticks more before allowing this signal to change again
                    -- this in order to keep the right sample if another trigger happens before the 
                    -- actual sample is sent in the header
                    if (hold_trigsample_counter=X"400") then
                        hold_trigsample <= '0';
                        hold_trigsample_counter <= (others => '0');
                    else
                        hold_trigsample <= '1';
                        hold_trigsample_counter <= std_logic_vector(hold_trigsample_counter + 1);
                    end if;
                end if;
            end if;
        end if;
    end process xc_trigsample_proc;

    trigsample <= trigsample_reg;
    triggered <= triggered_core;

end trig_xc_arch;